// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/ONSdigital/dp-redis"
	"sync"
)

var (
	lockResulterMockResult sync.RWMutex
)

// Ensure, that ResulterMock does implement Resulter.
// If this is not the case, regenerate this file with moq.
var _ redis.Resulter = &ResulterMock{}

// ResulterMock is a mock implementation of redis.Resulter.
//
//     func TestSomethingThatUsesResulter(t *testing.T) {
//
//         // make and configure a mocked redis.Resulter
//         mockedResulter := &ResulterMock{
//             ResultFunc: func() (string, error) {
// 	               panic("mock out the Result method")
//             },
//         }
//
//         // use mockedResulter in code that requires redis.Resulter
//         // and then make assertions.
//
//     }
type ResulterMock struct {
	// ResultFunc mocks the Result method.
	ResultFunc func() (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Result holds details about calls to the Result method.
		Result []struct {
		}
	}
}

// Result calls ResultFunc.
func (mock *ResulterMock) Result() (string, error) {
	if mock.ResultFunc == nil {
		panic("ResulterMock.ResultFunc: method is nil but Resulter.Result was just called")
	}
	callInfo := struct {
	}{}
	lockResulterMockResult.Lock()
	mock.calls.Result = append(mock.calls.Result, callInfo)
	lockResulterMockResult.Unlock()
	return mock.ResultFunc()
}

// ResultCalls gets all the calls that were made to Result.
// Check the length with:
//     len(mockedResulter.ResultCalls())
func (mock *ResulterMock) ResultCalls() []struct {
} {
	var calls []struct {
	}
	lockResulterMockResult.RLock()
	calls = mock.calls.Result
	lockResulterMockResult.RUnlock()
	return calls
}
